{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Relat\u00f3rio Parcial","text":""},{"location":"#heuristicas","title":"Heur\u00edsticas","text":"<ul> <li><code>guloso</code></li> <li><code>aleat\u00f3rio</code></li> </ul>"},{"location":"#implementacao","title":"Implementa\u00e7\u00e3o","text":""},{"location":"#arquivos-em-comum-dir-helpers","title":"Arquivos em comum (dir: <code>helpers</code>)","text":""},{"location":"#funcoes","title":"Fun\u00e7\u00f5es","text":"<pre><code>void read_movies_data(std::vector&lt;movie&gt; &amp;movies, int n_mov);\nvoid read_cats_limit(std::map&lt;int, int&gt; &amp;lim_cats, int n_cat);\nvoid include_movie(movie &amp;curr_movie, std::vector&lt;movie&gt; &amp;movies, int &amp;times_filed);\nvoid set_cats_limit(std::map&lt;int, int&gt; &amp;lim_cats, int mov_cat, int &amp;cats_limit);\nvoid print_agenda(std::vector&lt;movie&gt; selected);\n</code></pre> <p>Input handle:</p> <ul> <li><code>read_movies_data</code>: l\u00ea os dados dos filmes do arquivo de input.</li> <li><code>read_cats_limit</code>: l\u00ea o limite de filmes por categoria do arquivo de input.</li> </ul> <p>Run time:</p> <ul> <li><code>include_movie</code>: inclui um filme na agenda e incrementa um contador de hor\u00e1rios preenchidos (<code>times_filed</code>).</li> <li><code>set_cats_limit</code>: decrementa o limite de filmes por categoria. Caso o limite de certa categoria seja atingido, \u00e9 decrementado o n\u00famero de categorias que ainda podem ser preenchidas (<code>cats_limit</code>).</li> </ul> <p>Output handle:</p> <ul> <li><code>print_agenda</code>: imprime a agenda de filmes selecionados - func\u00e3o para verificac\u00e3o visual.</li> </ul>"},{"location":"#otimizacoes","title":"Otimiza\u00e7\u00f5es","text":"<ul> <li>Caso j\u00e1 tenha extinguido todos os filmes de todas as categorias, a func\u00e3o para (<code>cats_limit</code> ser 0).</li> <li>Caso j\u00e1 tenha preenchido 24hrs, a fun\u00e7\u00e3o para (<code>times_filed</code> ser 24).</li> <li>obs: se o filme passa das 24hrs, ele n\u00e3o incrementa times_filed, a ideia \u00e9 liberar assistir na madrugada e apenas parar quando o dia todo foi preenchido.</li> </ul>"},{"location":"#overview","title":"Overview","text":"<p>Em todas as implementacoes, a fun\u00e7\u00e3o <code>main</code> \u00e9 respons\u00e1vel por ler os dados de input, ordenar os filmes por hor\u00e1rio de t\u00e9rmino (a implementac\u00e3o guloso selecionada) e chamar a fun\u00e7\u00e3o <code>select_movies</code> que \u00e9 respons\u00e1vel por selecionar os filmes. A fun\u00e7\u00e3o <code>main</code> tamb\u00e9m \u00e9 respons\u00e1vel por imprimir o tempo de execu\u00e7\u00e3o do algoritmo.</p> <p>Detalhes:</p> <ul> <li>Filmes que acabam e terminam no mesmo hor\u00e1rio s\u00e3o tratados igual filmes que tem 2 horas (comecam em t e acabam em t+1)</li> <li>\u00c9 permitido comecar a ver um filme antes da meia noite, e virar a madrugada</li> </ul>"},{"location":"#guloso","title":"Guloso","text":""},{"location":"#funcao-de-selecao-de-filmes","title":"Funcao de selec\u00e3o de filmes","text":"<pre><code>int select_movies(std::vector&lt;movie&gt; &amp;movies, std::vector&lt;movie&gt; &amp;selected, std::map&lt;int, int&gt; &amp;lim_cats, int n_cat);\n</code></pre> <p>argumentos:</p> <ul> <li><code>movies</code>: vetor de filmes a serem selecionados.</li> <li><code>selected</code>: vetor de filmes selecionados.</li> <li><code>lim_cats</code>: mapa de limites de filmes por categoria.</li> <li><code>n_cat</code>: n\u00famero de categorias - utilizado para otimizac\u00e3o, cada vez que uma categoria \u00e9 preenchida (limite atingido), esse contador \u00e9 subtra\u00eddo, se o mesmo chega em zero (todas categorias atingiram o limite) o c\u00f3digo para.</li> <li><code>retorno</code>: tempo de tela total dos filmes selecionados.</li> </ul> <p>A l\u00f3gica da escolha \u00e9 feita da seguinte forma:</p> <ul> <li>Para cada filme, verifica se o hor\u00e1rio de t\u00e9rmino \u00e9 maior que o hor\u00e1rio de t\u00e9rmino do filme anterior.</li> <li>Caso seja maior:<ul> <li>Atualiza o hor\u00e1rio de t\u00e9rmino dos filmes (para ser igual o do filme na iterac\u00e3o) - isso significa que certo hor\u00e1rio n\u00e3o tem nenhum filme, ou todos filmes do hor\u00e1rio j\u00e1 foram considerados.</li> <li>Verifica se algum novo filme foi selecionado (desde a \u00faltima inclus\u00e3o)</li> <li>Caso foi, adiciona o filme selecionado na agenda.</li> </ul> </li> <li>Continua a itera\u00e7\u00e3o.<ul> <li>Compara se o filme atual cabe na agenda (checando hor\u00e1rios e filmes por categoria).</li> <li>Compara o inicio do filme, com o in\u00edcio do antigo filme selecionado - dos filmes que terminam neste hor\u00e1rio, qual comeca mais cedo?.</li> <li>Caso o filme atual seja mais cedo, substitui o antigo filme selecionado.</li> </ul> </li> </ul>"},{"location":"#valgrind","title":"Valgrind","text":"<pre><code>-- line 2 ----------------------------------------\n    .  #include &lt;cassert&gt;\n.  #include &lt;chrono&gt;\n.  using namespace std;\n.  .  bool hasSlot(movie curr, movie prev) {\n.    return curr.start &gt;= prev.end;\n.  }\n.  13  void select_movies(vector&lt;movie&gt; &amp;movies, vector&lt;movie&gt; &amp;selected, map&lt;int, int&gt; &amp;lim_cats, int n_cat) {\n1    int time_end = 0;\n1    int min_time = 100;\n1    bool has_selected = false;\n1    int times_filed = 0;\n1    movie last_selected = {0, 0, 0, 0};\n.    movie selected_movie;\n2,976    for(auto&amp; mov: movies) {\n.      3,000      if(n_cat &lt;= 0) return;\n2,000      if(times_filed &gt; 24) return;\n.  3,000      if(mov.end &gt; time_end) {\n.        time_end = mov.end;\n.  84        if (has_selected) {\n23          min_time = 100;\n96          include_movie(selected_movie, selected, times_filed);\n3,668  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:include_movie(movie&amp;, std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, int&amp;) (23x)\n92          set_cats_limit(lim_cats, selected_movie.cat, n_cat);\n1,691  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:set_cats_limit(std::map&lt;int, int, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;&amp;, int, int&amp;) (23x)\n46          last_selected = selected_movie;\n46          has_selected = false;\n.        };\n.      }\n7,034      if(mov.start &lt; min_time &amp;&amp; lim_cats[mov.cat] &gt; 0 &amp;&amp; hasSlot(mov, last_selected))  {\n78        selected_movie = mov;\n26        min_time = mov.start;\n26        has_selected = true;\n.      }\n.    }\n11  }\n.  12  int main(int argc, char *argv[]) {\n.    int n_mov, n_cat;\n.  .    map&lt;int, int&gt; lim_cats;\n.    vector&lt;movie&gt; movies, selected;\n.  7    cin &gt;&gt; n_mov &gt;&gt; n_cat;\n8,358  =&gt; ???:0x0000000000109200 (2x)\n.  1    movies.reserve(n_mov);\n.  4    set_cats_limit(lim_cats, n_cat);\n9,254  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:set_cats_limit(std::map&lt;int, int, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;&amp;, int) (1x)\n.  4    read_movies_data(movies, n_mov);\n3,294,712  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:read_movies_data(std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, int) (1x)\n.  .    sort(movies.begin(), movies.end(), [](auto&amp; i, auto&amp; j){return i.end &lt; j.end;});\n.  2    chrono::steady_clock::time_point begin = chrono::steady_clock::now();\n950  =&gt; ???:0x00000000001092d0 (1x)\n.  5    select_movies(movies, selected, lim_cats, n_cat);\n50,528  =&gt; guloso.cpp:select_movies(std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, std::map&lt;int, int, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;&amp;, int) (1x)\n.  1    chrono::steady_clock::time_point end = chrono::steady_clock::now();\n40  =&gt; ???:0x00000000001092d0 (1x)\n.  .    cout &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end - begin).count();\n.  2    if(argc &gt; 1) return 0;\n.  .    cout &lt;&lt; endl;\n    .  \n    2    print_agenda(selected);\n250,112  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:print_agenda(std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;) (1x)\n.  1    return 0;\n.  15  }\n</code></pre> <p>Como pode-se observar na an\u00e1lise do valgrind, as \u00fanicas func\u00f5es que tem pior desempenho s\u00e3o as de leitura dos inputs, e as de print da agenda - contudo as mesmas s\u00e3o chamadas apenas uma vez. As outras func\u00f5es s\u00e3o chamadas muitas vezes, mas n\u00e3o consomem tanto tempo, e a maior parte do tempo \u00e9 gasto em compara\u00e7\u00f5es e atribui\u00e7\u00f5es.</p>"},{"location":"#aleatorio","title":"Aleat\u00f3rio","text":""},{"location":"#funcao-de-selecao-de-filmes_1","title":"Funcao de selec\u00e3o de filmes","text":"<pre><code>int select_movies(vector&lt;movie&gt; &amp;movies, vector&lt;movie&gt; &amp;selected, map&lt;int, int&gt; &amp;lim_cats, map&lt;int, bool&gt; &amp;filled_slots, int n_cat, int n_mov);\n</code></pre> <p>argumentos:</p> <ul> <li><code>movies</code>: vetor de filmes a serem selecionados.</li> <li><code>selected</code>: vetor de filmes selecionados.</li> <li><code>lim_cats</code>: mapa de limites de filmes por categoria.</li> <li><code>filled_slots</code>: mapa de slots preenchidos - cada vez que um filme \u00e9 adicionado, ele preenche seus hor\u00e1rios no mapa.</li> <li><code>n_cat</code>: n\u00famero de categorias - utilizado para otimizac\u00e3o, cada vez que uma categoria \u00e9 preenchida (limite atingido), esse contador \u00e9 subtra\u00eddo, se o mesmo chega em zero (todas categorias atingiram o limite) o c\u00f3digo para.</li> <li><code>n_mov</code>: n\u00famero de filmes lido</li> <li><code>retorno</code>: tempo de tela total dos filmes selecionados.</li> </ul> <p>A l\u00f3gica da escolha \u00e9 feita da seguinte forma:</p> <ul> <li>Implementa a mesma l\u00f3gica descrita na gulosa</li> <li>Dentro do loop principal, checa se um filme aleat\u00f3rio pode ser adiconado - com 25% de chance</li> <li>Caso positivo:<ul> <li>Checa o limite de categorias e se o slot est\u00e1 dispon\u00edvel (cabe no hor\u00e1rio)</li> <li>Caso o filme seja adicionado, \u00e9 realizado um check para ver se o filme selecionado pela gulosa ainda cabe (categoria e slot)</li> </ul> </li> </ul>"},{"location":"#valgrind_1","title":"Valgrind","text":"<p><pre><code>-- line 3 ----------------------------------------\n    .  #include &lt;random&gt;\n.  #include &lt;chrono&gt;\n.  .  #define SEED 42\n.  #define PROB 0.75\n.  .  using namespace std;\n.  2,618  bool hasSlot(movie curr, map&lt;int, bool&gt; &amp;filled_slots) {\n724    if(curr.end == curr.start) return !filled_slots[curr.start];\n1,164    for(int i = curr.start; i &lt; curr.end; i++) {\n976      if(filled_slots[i]) return false;\n.    }\n14    return true;\n1,904  }\n.  121  void fill_slot(map&lt;int, bool&gt; &amp;filled_slots, movie curr) {\n33    if(curr.end == curr.start) {\n1      filled_slots[curr.start] = true;\n1      return;\n.    }\n136    for(int i = curr.start; i &lt; curr.end; i++) {\n24      filled_slots[i] = true;\n.    }\n88  }\n.  17  void select_movies(vector&lt;movie&gt; &amp;movies, vector&lt;movie&gt; &amp;selected, map&lt;int, int&gt; &amp;lim_cats, map&lt;int, bool&gt; &amp;filled_slots, int n_cat, int n_mov) {\n.    uniform_real_distribution&lt;double&gt; distribution(0.0, 1.0);\n.    default_random_engine generator;\n3    generator.seed(SEED + time(0));\n8  =&gt; ???:0x0000000000109260 (1x)\n.  2    int time_end = 0;\n1    int min_time = 100;\n1    int times_filed = 0;\n1    bool has_selected = false;\n.  .    //movie last_selected = {0, 0, 0, 0};\n.    movie selected_movie;\n844    for(int i = 0; i &lt; n_mov; i++) {\n848      if(n_cat &lt;= 0) return;\n424      if(times_filed &gt; 24) return;\n844      if(movies[i].end &gt; time_end) {\n.        time_end = movies[i].end;\n.  24        if (has_selected) {\n15          include_movie(selected_movie, selected, times_filed);\n344  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:include_movie(movie&amp;, std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, int&amp;) (3x)\n12          set_cats_limit(lim_cats, selected_movie.cat, n_cat);\n220  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:set_cats_limit(std::map&lt;int, int, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;&amp;, int, int&amp;) (3x)\n12          fill_slot(filled_slots, selected_movie);\n182  =&gt; aleatorio.cpp:fill_slot(std::map&lt;int, bool, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, bool&gt; &gt; &gt;&amp;, movie) (3x)\n.  9          min_time = 100;\n6          has_selected = false;\n.        };\n.      }\n422      if(distribution(generator) &gt; PROB) {\n48        uniform_int_distribution&lt;int&gt; distribution(i, movies.size()-1);\n.        int p = distribution(generator);\n561        if(hasSlot(movies[p], filled_slots) &amp;&amp; lim_cats[movies[p].cat] &gt; 0) {\n12,009  =&gt; aleatorio.cpp:hasSlot(movie, std::map&lt;int, bool, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, bool&gt; &gt; &gt;&amp;) (48x)\n24          include_movie(movies[p], selected, times_filed);\n2,601  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:include_movie(movie&amp;, std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, int&amp;) (8x)\n48          set_cats_limit(lim_cats, movies[p].cat, n_cat);\n549  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:set_cats_limit(std::map&lt;int, int, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;&amp;, int, int&amp;) (8x)\n48          fill_slot(filled_slots, movies[p]);\n1,064  =&gt; aleatorio.cpp:fill_slot(std::map&lt;int, bool, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, bool&gt; &gt; &gt;&amp;, movie) (8x)\n.          48          if(!(hasSlot(selected_movie, filled_slots) &amp;&amp; lim_cats[selected_movie.cat] &gt; 0)) {\n460  =&gt; aleatorio.cpp:hasSlot(movie, std::map&lt;int, bool, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, bool&gt; &gt; &gt;&amp;) (8x)\n16            min_time = 100;\n16            has_selected = false;\n.          }\n.        }\n.      }\n2,534      if(movies[i].start &lt; min_time &amp;&amp; lim_cats[movies[i].cat] &gt; 0 &amp;&amp; hasSlot(movies[i], filled_slots))  {\n11,881  =&gt; aleatorio.cpp:hasSlot(movie, std::map&lt;int, bool, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, bool&gt; &gt; &gt;&amp;) (182x)\n8        selected_movie = movies[i];\n8        min_time = movies[i].start;\n8        has_selected = true;\n.      }\n.    }\n11  }\n.  12  int main(int argc, char *argv[]) {\n.    int n_mov, n_cat;\n.    // int id, n, w, weigth, val;\n.  .    map&lt;int, bool&gt; filled_slots;\n.    map&lt;int, int&gt; lim_cats;\n.    vector&lt;movie&gt; movies, selected;\n.  8    cin &gt;&gt; n_mov &gt;&gt; n_cat;\n8,358  =&gt; ???:0x0000000000109210 (2x)\n.  1    movies.reserve(n_mov);\n.  5    set_cats_limit(lim_cats, n_cat);\n9,254  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:set_cats_limit(std::map&lt;int, int, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;&amp;, int) (1x)\n.  5    read_movies_data(movies, n_mov);\n3,294,712  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:read_movies_data(std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, int) (1x)\n.  .    sort(movies.begin(), movies.end(), [](auto&amp; i, auto&amp; j){return i.end &lt; j.end;});\n.  2    chrono::steady_clock::time_point begin = chrono::steady_clock::now();\n950  =&gt; ???:0x00000000001092f0 (1x)\n.  8    select_movies(movies, selected, lim_cats, filled_slots, n_cat, n_mov);\n55,592  =&gt; aleatorio.cpp:select_movies(std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, std::map&lt;int, int, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;&amp;, std::map&lt;int, bool, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, bool&gt; &gt; &gt;&amp;, int, int) (1x)\n.  1    chrono::steady_clock::time_point end = chrono::steady_clock::now();\n40  =&gt; ???:0x00000000001092f0 (1x)\n.  .    cout &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end - begin).count();\n.  2    if(argc &gt; 1) return 0;\n.  .    cout &lt;&lt; endl;\n    .  \n    .    sort(selected.begin(), selected.end(), [](auto&amp; i, auto&amp; j){return i.start &lt; j.start;});\n.  2    print_agenda(selected);\n134,776  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:print_agenda(std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;) (1x)\n.  15  }\n--------------------------------------------------------------------------------\n</code></pre> Como pode-se observar na an\u00e1lise do valgrind, as \u00fanicas func\u00f5es que consomem mais tempo s\u00e3o as de leitura dos inputs, e as de print da agenda - contudo as mesmas s\u00e3o chamadas apenas uma vez. As outras func\u00f5es s\u00e3o chamadas muitas vezes, mas n\u00e3o consomem tanto tempo, e a maior parte do tempo \u00e9 gasto em compara\u00e7\u00f5es e atribui\u00e7\u00f5es. Se comparado ao guloso, a func\u00e3o <code>select_movies</code> do aleat\u00f3rio tem desempenho pior, pois a l\u00f3gica de validac\u00e3o para incluir um filme \u00e9 mais complexa - usa um dicion\u00e1rio, equanto na gulosa, como \u00e9 sequencial, apenas compara com o filme anterior.</p>"},{"location":"#resultados","title":"Resultados","text":""},{"location":"#overview-graficos-3d","title":"Overview (Gr\u00e1ficos 3D)","text":"<p>Para o aleat\u00f3rio, cada entrada foi rodada 10 vezes (para ver diferenca entre os outputs) j\u00e1 para o guloso, apenas uma (output determin\u00edstico).</p> <p>Assim no gr\u00e1fico do aleat\u00f3rio foram plotadas 2 superf\u00edcies (considerando as 10 iteracoes):</p> <ul> <li>O m\u00ednimo atingido - curva vermelha</li> <li>E o m\u00e1ximo - curva azul</li> </ul>"},{"location":"#tempo-de-execucao","title":"Tempo de execuc\u00e3o","text":"Guloso Aleat\u00f3rio <p>Podemos ver que o tempo de execuc\u00e3o do guloso claramente aumenta conforme tem mais categorias e mais filmes. Uma maior quantidade de filmes o faz aumentar pois ele vai recusar uma grande quantidade de filmes inv\u00e1lidos (vai checando os do mesmo hor\u00e1rio at\u00e9 achar o que comeca mais cedo). Um maior numero de categorias faz com que seja muito dificil do limite ser atingido (vai ter mais categoria que filmes selecionados), portanto a parte que para o c\u00f3digo caso nenhuma categoria tenha mais espaco, nunca \u00e9 ativada.</p> <p>No gr\u00e1fico do aleat\u00f3rio, se comparado ao guloso temos as seguintes situac\u00f5es</p> <ul> <li>No geral parece ser parecido</li> <li>A curva m\u00e1xima \u00e9 mais demorada em alguns casos</li> <li>A curva minima aparenta ser quase sempre - principalmente em casos com muitos filmes</li> </ul> <p>curva m\u00e1xima</p> <p>Como o loop principal da aleat\u00f3rio (gerar valores aleatorios, ver se cabe, a agenda \u00e9 um dicion\u00e1rio) \u00e9 mais complexo que o da gulosa (apenas verifica se o filme comeca depois que o anterior termina), caso eles tivessem a mesma quantidade de iterac\u00f5es, \u00e9 de se esperar que o aleat\u00f3rio demore mais.</p> <p>Dito isso, o motivo da demora a mais deve se dar o fato de que v\u00e1rias soluc\u00f5es aleat\u00f3rias fossem escolhidas (p &lt; 25), mas poucas tivessem espaco para serem incluidas. Assim o algor\u00edtimo deve ter iterac\u00f5es similares ao do guloso, mas com verificac\u00f5es mais demoradas.</p> <p>curva minima</p> <p>Se as verificac\u00f5es do aleat\u00f3rio s\u00e3o mais complexas, como ele \u00e9 mais r\u00e1pido?</p> <p>Simples, ambos os c\u00f3digos tem otimizac\u00f5es que param quando as 24hrs do dia enchem. O aleat\u00f3rio, nesses casos mais r\u00e1pidos, faz a inclus\u00e3o de filmes mais longos que ocupam mais a agenda. Dessa forma, enquanto o guloso est\u00e1 recusando v\u00e1rios filmes que n\u00e3o cabem, o aleat\u00f3rio, al\u00e9m de fazer isso, inclui filmes no meio/no final da agenda para ench\u00ea-la.</p>"},{"location":"#tempo-de-tela","title":"Tempo de tela","text":"Guloso Aleat\u00f3rio <p>Com esses dois gr\u00e1ficos, n\u00e3o se pode concluir muito. Os resultados mais aparentes s\u00e3o que:</p> <ul> <li>Ambos chegam a um tempo de 24hrs (ou perto), quando se atinge mais ou menos 10 categorias<ul> <li>quando h\u00e1 poucos filmes, parece variar mais.</li> </ul> </li> <li>O aleat\u00f3rio varia em torno de 24hrs - isso se d\u00e1 pois ele consegue colocar filmes mais longos que viram na madrugada</li> <li>O guloso para em 24 conforme a quantidade de filmes aumenta (diminui a chance de sobrar um slot para virar a madrugada, quando se atinge os filmes finais)</li> </ul> <p>Vamos analizar mais a fundo na sess\u00e3o 2D, para ver o comportamento com uma menor quantidade de filmes e categorias.</p>"},{"location":"#quantidade-de-filmes-selecionados","title":"Quantidade de filmes selecionados","text":"Guloso Aleat\u00f3rio <p>Ao observar o gr\u00e1fico do guloso, pode-se concluir que em torno de 10 categorias, ele passa a sempre (ou quase sempre), ter 24 filmes - isso porque fica quase imposs\u00edvel atingir o limite de categoria, portanto sempre ter\u00e1 um filme para ser encaixado no slot. Como os filmes s\u00e3o percorridos em ordem de t\u00e9rmino crescente, com uma grande quantidade de filme \u00e9 certo que ter\u00e1 algum filme de durac\u00e3o 1 que possa ser incluido.</p> <p>Por outro lado o guloso varia em torno de 12. Isso pois ele pode, ao acaso, escolher algum filme longo (e na maioria das vezes vai) que ocupa mais tempo na agenda.</p> <p>Como no caso anterior, ser\u00e1 feita uma an\u00e1lise mais completa nos gr\u00e1ficos 2D.</p>"},{"location":"#aprofundando-graficos-2d","title":"Aprofundando (Gr\u00e1ficos 2D)","text":""},{"location":"#tempo-de-execucao_1","title":"Tempo de execuc\u00e3o","text":"1 category 2 categories 3 categories 5 categories 10 categories 20 categories <p>Os gr\u00e1ficos com categoria fixadas mostram como o comportamento do aleat\u00f3rio muda bastante - realmente depende se os filmes escolhidos podem ser incluidos ou n\u00e3o.</p> <p>Com categorias fixadas \u00e9 dificil escolher um vencedor. Vamos declarar um empate, pois, mesmo que o aleat\u00f3rio ganhe em varias vezes, perde em algumas.</p> 10 movies 100 movies 1000 movies 10000 movies <p>Com esses gr\u00e1ficos de filmes fixados fica claro que com poucos filmes o guloso leva vantagem - isso porque ele n\u00e3o verifica tantos filmes inv\u00e1lidos, e com menos iterac\u00f5es, a chance de filmes ocuparem a agenda toda \u00e9 menor.</p> <p>Contudo com muitos filmes, o aleat\u00f3rio claramente \u00e9 superior - motivo j\u00e1 explicado.</p>"},{"location":"#tempo-de-tela_1","title":"Tempo de tela","text":"1 category 2 categories 3 categories 5 categories 10 categories 20 categories <p>Observando os gr\u00e1ficos com categorias fixadas, pode-se tomar as seguintes conclus\u00f5es:</p> <ul> <li>De fato, ao chegar em 10 categorias, o guloso n\u00e3o passa de 24hrs de tempo de tela</li> <li>Independentemente do n\u00famero de categorias, o tempo de tela do aleat\u00f3rio \u00e9 maior. Isso se da pelo fato de ter mais chances de escolher filmes longos do que o guloso. O guloso tende a encher as 24 horas com filmes curtos, enquanto no aleat\u00f3rio, a escolha de filmes que viram a madrugada (ainda mais quando s\u00e3o longos) traz uma vantagem enorme.</li> </ul> 10 movies 100 movies 1000 movies 10000 movies <p>Observando os gr\u00e1ficos com filmes fixados, pode-se tomar as seguintes conclus\u00f5es:</p> <ul> <li>Com poucos filmes, o desempenho das duas heur\u00edsticas \u00e9 parecido - pode-se at\u00e9 argumentar que o guloso \u00e9 melhor, pois o aleat\u00f3rio \u00e9 menos consistente.</li> <li>Com muitos filmes, o aleat\u00f3rio \u00e9 melhor - justamente pelo motivo, j\u00e1 explicado, dos filmes que viram a madrugada</li> </ul>"},{"location":"#quantidade-de-filmes-selecionados_1","title":"Quantidade de filmes selecionados","text":"1 category 2 categories 3 categories 5 categories 10 categories 20 categories <p>Observando os gr\u00e1ficos com categorias fixadas, pode-se tomar as seguintes conclus\u00f5es:</p> <ul> <li>com uma ou duas, o n\u00famero de filmes \u00e9 igual (ou praticamente igual)</li> <li>A partir de 3 categorias o guloso comeca a selecionar mais filmes</li> <li>Com muitas categorias, quando se tem mais de 1000 filmes, o guloso sempre seleciona mais, fica fixado em 24 filmes.</li> </ul> 10 movies 100 movies 1000 movies 10000 movies <p>Observando os gr\u00e1ficos com filmes fixados, pode-se tomar as seguintes conclus\u00f5es:</p> <ul> <li>Logo de cara - 100 filmes - o guloso j\u00e1 comeca a se destacar, ou seja, seleciona mais filmes</li> <li>Com uma quantidade muito grande, as categorias n\u00e3o influenciam muito, o guloso fixa em 24 filmes</li> </ul>"},{"location":"#conclusao","title":"Conclus\u00e3o","text":"<p>O aleat\u00f3rio traz uma funcionalidade que o guloso n\u00e3o tem: exploration. O mesmo consegue sair do estado atual e gerar novos valores sem relac\u00e3o a tal estado. Por esse motivo o mesmo ganha um destaque em tempo de tela, a maior chance de selecionar filmes mais longos, ainda mais quando viram a madrugada, \u00e9 um game-changer. Por fazer tais escolhas de filmes longos, o seu run-time tamb\u00e9m tende a ser menor. </p> <p>Contudo, quando se opta por filmes mais longos, uma m\u00e9trica \u00e9 sacrificada: a quantidade de filmes. Nesta m\u00e9trica, por tender a sempre escolher filmes que caibam nos menores slots, ou seja, filmes curtos, o guloso leva uma grande vantagem.</p>"}]}