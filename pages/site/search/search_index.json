{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Relat\u00f3rio Parcial","text":""},{"location":"#heuristicas","title":"Heur\u00edsticas","text":"<ul> <li><code>guloso</code></li> <li><code>aleat\u00f3rio</code></li> </ul>"},{"location":"#implementacao","title":"Implementa\u00e7\u00e3o","text":""},{"location":"#arquivos-em-comum-dir-helpers","title":"Arquivos em comum (dir: <code>helpers</code>)","text":""},{"location":"#funcoes","title":"Fun\u00e7\u00f5es","text":"<pre><code>void read_movies_data(std::vector&lt;movie&gt; &amp;movies, int n_mov);\nvoid read_cats_limit(std::map&lt;int, int&gt; &amp;lim_cats, int n_cat);\nvoid include_movie(movie &amp;curr_movie, std::vector&lt;movie&gt; &amp;movies, int &amp;times_filed);\nvoid set_cats_limit(std::map&lt;int, int&gt; &amp;lim_cats, int mov_cat, int &amp;cats_limit);\nvoid print_agenda(std::vector&lt;movie&gt; selected);\n</code></pre> <p>Input handle:</p> <ul> <li><code>read_movies_data</code>: l\u00ea os dados dos filmes do arquivo de input.</li> <li><code>read_cats_limit</code>: l\u00ea o limite de filmes por categoria do arquivo de input.</li> </ul> <p>Run time:</p> <ul> <li><code>include_movie</code>: inclui um filme na agenda e incrementa um contador de hor\u00e1rios preenchidos (<code>times_filed</code>).</li> <li><code>set_cats_limit</code>: decrementa o limite de filmes por categoria. Caso o limite de certa categoria seja atingido, \u00e9 decrementado o n\u00famero de categorias que ainda podem ser preenchidas (<code>cats_limit</code>).</li> </ul> <p>Output handle:</p> <ul> <li><code>print_agenda</code>: imprime a agenda de filmes selecionados.</li> </ul>"},{"location":"#otimizacoes","title":"Otimiza\u00e7\u00f5es","text":"<ul> <li>Caso j\u00e1 tenha extinguido todos os filmes de todas as categorias, a func\u00e3o para (<code>cats_limit</code> ser 0).</li> <li>Caso j\u00e1 tenha preenchido 24hrs, a fun\u00e7\u00e3o para (<code>times_filed</code> ser 24).</li> </ul>"},{"location":"#guloso","title":"Guloso","text":""},{"location":"#overview","title":"Overview","text":"<pre><code>int main(int argc, char *argv[]) {\nint n_mov, n_cat;\nmap&lt;int, int&gt; lim_cats;\nvector&lt;movie&gt; movies, selected;\ncin &gt;&gt; n_mov &gt;&gt; n_cat;\nmovies.reserve(n_mov);\nread_cats_limit(lim_cats, n_cat);\nread_movies_data(movies, n_mov);\nsort(movies.begin(), movies.end(), [](auto&amp; i, auto&amp; j){return i.end &lt; j.end;});\nchrono::steady_clock::time_point begin = chrono::steady_clock::now();\nselect_movies(movies, selected, lim_cats, n_cat);\nchrono::steady_clock::time_point end = chrono::steady_clock::now();\ncout &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end - begin).count();\nif(argc &gt; 1) return 0;\ncout &lt;&lt; endl;\nprint_agenda(selected);\nreturn 0;\n}\n</code></pre> <p>Como pode-se ver, a fun\u00e7\u00e3o <code>main</code> \u00e9 respons\u00e1vel por ler os dados de input, ordenar os filmes por hor\u00e1rio de t\u00e9rmino (a implementac\u00e3o guloso selecionada) e chamar a fun\u00e7\u00e3o <code>select_movies</code> que \u00e9 respons\u00e1vel por selecionar os filmes. A fun\u00e7\u00e3o <code>main</code> tamb\u00e9m \u00e9 respons\u00e1vel por imprimir o tempo de execu\u00e7\u00e3o do algoritmo.</p>"},{"location":"#funcao-principal","title":"Fun\u00e7\u00e3o principal","text":"<p><pre><code>void select_movies(std::vector&lt;movie&gt; &amp;movies, std::vector&lt;movie&gt; &amp;selected, std::map&lt;int, int&gt; &amp;lim_cats, int n_cat);\n</code></pre> A l\u00f3gica da escolha \u00e9 feita da seguinte forma:</p> <ul> <li>Para cada filme, verifica se o hor\u00e1rio de t\u00e9rmino \u00e9 maior que o hor\u00e1rio de t\u00e9rmino do filme anterior.</li> <li>Caso seja maior:<ul> <li>Atualiza o hor\u00e1rio de t\u00e9rmino dos filmes (para ser igual o do filme na iterac\u00e3o).</li> <li>Verifica se algum novo filme foi selecionado (desde a \u00faltima inclus\u00e3o)</li> <li>Caso foi, adiciona o filme selecionado na agenda.</li> </ul> </li> <li>Continua a itera\u00e7\u00e3o.<ul> <li>Compara se o filme atual cabe na agenda (checando hor\u00e1rios e filmes por categoria).</li> <li>Compara o inicio do filme, com o in\u00edcio do antigo filme selecionado.</li> <li>Caso o filme atual seja mais cedo, substitui o antigo filme selecionado.</li> </ul> </li> </ul>"},{"location":"#exemplos","title":"Exemplos","text":"<ul> <li>Exemplo 1</li> </ul>"},{"location":"#valgrind","title":"Valgrind","text":"<pre><code>-- line 2 ----------------------------------------\n    .  #include &lt;cassert&gt;\n.  #include &lt;chrono&gt;\n.  using namespace std;\n.  .  bool hasSlot(movie curr, movie prev) {\n.    return curr.start &gt;= prev.end;\n.  }\n.  13  void select_movies(vector&lt;movie&gt; &amp;movies, vector&lt;movie&gt; &amp;selected, map&lt;int, int&gt; &amp;lim_cats, int n_cat) {\n1    int time_end = 0;\n1    int min_time = 100;\n1    bool has_selected = false;\n1    int times_filed = 0;\n1    movie last_selected = {0, 0, 0, 0};\n.    movie selected_movie;\n2,976    for(auto&amp; mov: movies) {\n.      3,000      if(n_cat &lt;= 0) return;\n2,000      if(times_filed &gt; 24) return;\n.  3,000      if(mov.end &gt; time_end) {\n.        time_end = mov.end;\n.  84        if (has_selected) {\n23          min_time = 100;\n96          include_movie(selected_movie, selected, times_filed);\n3,668  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:include_movie(movie&amp;, std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, int&amp;) (23x)\n92          set_cats_limit(lim_cats, selected_movie.cat, n_cat);\n1,691  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:set_cats_limit(std::map&lt;int, int, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;&amp;, int, int&amp;) (23x)\n46          last_selected = selected_movie;\n46          has_selected = false;\n.        };\n.      }\n7,034      if(mov.start &lt; min_time &amp;&amp; lim_cats[mov.cat] &gt; 0 &amp;&amp; hasSlot(mov, last_selected))  {\n78        selected_movie = mov;\n26        min_time = mov.start;\n26        has_selected = true;\n.      }\n.    }\n11  }\n.  12  int main(int argc, char *argv[]) {\n.    int n_mov, n_cat;\n.  .    map&lt;int, int&gt; lim_cats;\n.    vector&lt;movie&gt; movies, selected;\n.  7    cin &gt;&gt; n_mov &gt;&gt; n_cat;\n8,358  =&gt; ???:0x0000000000109200 (2x)\n.  1    movies.reserve(n_mov);\n.  4    set_cats_limit(lim_cats, n_cat);\n9,254  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:set_cats_limit(std::map&lt;int, int, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;&amp;, int) (1x)\n.  4    read_movies_data(movies, n_mov);\n3,294,712  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:read_movies_data(std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, int) (1x)\n.  .    sort(movies.begin(), movies.end(), [](auto&amp; i, auto&amp; j){return i.end &lt; j.end;});\n.  2    chrono::steady_clock::time_point begin = chrono::steady_clock::now();\n950  =&gt; ???:0x00000000001092d0 (1x)\n.  5    select_movies(movies, selected, lim_cats, n_cat);\n50,528  =&gt; guloso.cpp:select_movies(std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, std::map&lt;int, int, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;&amp;, int) (1x)\n.  1    chrono::steady_clock::time_point end = chrono::steady_clock::now();\n40  =&gt; ???:0x00000000001092d0 (1x)\n.  .    cout &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end - begin).count();\n.  2    if(argc &gt; 1) return 0;\n.  .    cout &lt;&lt; endl;\n    .  \n    2    print_agenda(selected);\n250,112  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:print_agenda(std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;) (1x)\n.  1    return 0;\n.  15  }\n</code></pre>"},{"location":"#aleatorio","title":"Aleat\u00f3rio","text":""},{"location":"#overview_1","title":"Overview","text":"<pre><code>int main(int argc, char *argv[]) {\nint n_mov, n_cat;\n// int id, n, w, weigth, val;\nmap&lt;int, bool&gt; filled_slots;\nmap&lt;int, int&gt; lim_cats;\nvector&lt;movie&gt; movies, selected;\ncin &gt;&gt; n_mov &gt;&gt; n_cat;\nmovies.reserve(n_mov);\nread_cats_limit(lim_cats, n_cat);\nread_movies_data(movies, n_mov);\nsort(movies.begin(), movies.end(), [](auto&amp; i, auto&amp; j){return i.end &lt; j.end;});\nchrono::steady_clock::time_point begin = chrono::steady_clock::now();\nselect_movies(movies, selected, lim_cats, filled_slots, n_cat, n_mov);\nchrono::steady_clock::time_point end = chrono::steady_clock::now();\ncout &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end - begin).count();\nif(argc &gt; 1) return 0;\ncout &lt;&lt; endl;\nsort(selected.begin(), selected.end(), [](auto&amp; i, auto&amp; j){return i.start &lt; j.start;});\nprint_agenda(selected);\n}\n</code></pre>"},{"location":"#resultados","title":"Resultados","text":""}]}