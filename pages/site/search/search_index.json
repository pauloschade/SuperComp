{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Relat\u00f3rio Parcial","text":""},{"location":"#heuristicas","title":"Heur\u00edsticas","text":"<ul> <li><code>guloso</code></li> <li><code>aleat\u00f3rio</code></li> </ul>"},{"location":"#implementacao","title":"Implementa\u00e7\u00e3o","text":""},{"location":"#arquivos-em-comum-dir-helpers","title":"Arquivos em comum (dir: <code>helpers</code>)","text":""},{"location":"#funcoes","title":"Fun\u00e7\u00f5es","text":"<pre><code>void read_movies_data(std::vector&lt;movie&gt; &amp;movies, int n_mov);\nvoid read_cats_limit(std::map&lt;int, int&gt; &amp;lim_cats, int n_cat);\nvoid include_movie(movie &amp;curr_movie, std::vector&lt;movie&gt; &amp;movies, int &amp;times_filed);\nvoid set_cats_limit(std::map&lt;int, int&gt; &amp;lim_cats, int mov_cat, int &amp;cats_limit);\nvoid print_agenda(std::vector&lt;movie&gt; selected);\n</code></pre> <p>Input handle:</p> <ul> <li><code>read_movies_data</code>: l\u00ea os dados dos filmes do arquivo de input.</li> <li><code>read_cats_limit</code>: l\u00ea o limite de filmes por categoria do arquivo de input.</li> </ul> <p>Run time:</p> <ul> <li><code>include_movie</code>: inclui um filme na agenda e incrementa um contador de hor\u00e1rios preenchidos (<code>times_filed</code>).</li> <li><code>set_cats_limit</code>: decrementa o limite de filmes por categoria. Caso o limite de certa categoria seja atingido, \u00e9 decrementado o n\u00famero de categorias que ainda podem ser preenchidas (<code>cats_limit</code>).</li> </ul> <p>Output handle:</p> <ul> <li><code>print_agenda</code>: imprime a agenda de filmes selecionados - func\u00e3o para verificac\u00e3o visual.</li> </ul>"},{"location":"#otimizacoes","title":"Otimiza\u00e7\u00f5es","text":"<ul> <li>Caso j\u00e1 tenha extinguido todos os filmes de todas as categorias, a func\u00e3o para (<code>cats_limit</code> ser 0).</li> <li>Caso j\u00e1 tenha preenchido 24hrs, a fun\u00e7\u00e3o para (<code>times_filed</code> ser 24).</li> <li>obs: se o filme passa das 24hrs, ele n\u00e3o incrementa times_filed, a ideia \u00e9 liberar assistir na madrugada e apenas parar quando o dia todo foi preenchido.</li> </ul>"},{"location":"#overview","title":"Overview","text":"<p>Em todas as implementacoes, a fun\u00e7\u00e3o <code>main</code> \u00e9 respons\u00e1vel por ler os dados de input, ordenar os filmes por hor\u00e1rio de t\u00e9rmino (a implementac\u00e3o guloso selecionada) e chamar a fun\u00e7\u00e3o <code>select_movies</code> que \u00e9 respons\u00e1vel por selecionar os filmes. A fun\u00e7\u00e3o <code>main</code> tamb\u00e9m \u00e9 respons\u00e1vel por imprimir o tempo de execu\u00e7\u00e3o do algoritmo.</p>"},{"location":"#guloso","title":"Guloso","text":""},{"location":"#funcao-de-selecao-de-filmes","title":"Funcao de selec\u00e3o de filmes","text":"<pre><code>int select_movies(std::vector&lt;movie&gt; &amp;movies, std::vector&lt;movie&gt; &amp;selected, std::map&lt;int, int&gt; &amp;lim_cats, int n_cat);\n</code></pre> <p>argumentos:</p> <ul> <li><code>movies</code>: vetor de filmes a serem selecionados.</li> <li><code>selected</code>: vetor de filmes selecionados.</li> <li><code>lim_cats</code>: mapa de limites de filmes por categoria.</li> <li><code>n_cat</code>: n\u00famero de categorias - utilizado para otimizac\u00e3o, cada vez que uma categoria \u00e9 preenchida (limite atingido), esse contador \u00e9 subtra\u00eddo, se o mesmo chega em zero (todas categorias atingiram o limite) o c\u00f3digo para.</li> <li><code>retorno</code>: tempo de tela total dos filmes selecionados.</li> </ul> <p>A l\u00f3gica da escolha \u00e9 feita da seguinte forma:</p> <ul> <li>Para cada filme, verifica se o hor\u00e1rio de t\u00e9rmino \u00e9 maior que o hor\u00e1rio de t\u00e9rmino do filme anterior.</li> <li>Caso seja maior:<ul> <li>Atualiza o hor\u00e1rio de t\u00e9rmino dos filmes (para ser igual o do filme na iterac\u00e3o) - isso significa que certo hor\u00e1rio n\u00e3o tem nenhum filme, ou todos filmes do hor\u00e1rio j\u00e1 foram considerados.</li> <li>Verifica se algum novo filme foi selecionado (desde a \u00faltima inclus\u00e3o)</li> <li>Caso foi, adiciona o filme selecionado na agenda.</li> </ul> </li> <li>Continua a itera\u00e7\u00e3o.<ul> <li>Compara se o filme atual cabe na agenda (checando hor\u00e1rios e filmes por categoria).</li> <li>Compara o inicio do filme, com o in\u00edcio do antigo filme selecionado - dos filmes que terminam neste hor\u00e1rio, qual comeca mais cedo?.</li> <li>Caso o filme atual seja mais cedo, substitui o antigo filme selecionado.</li> </ul> </li> </ul>"},{"location":"#valgrind","title":"Valgrind","text":"<pre><code>-- line 2 ----------------------------------------\n    .  #include &lt;cassert&gt;\n.  #include &lt;chrono&gt;\n.  using namespace std;\n.  .  bool hasSlot(movie curr, movie prev) {\n.    return curr.start &gt;= prev.end;\n.  }\n.  13  void select_movies(vector&lt;movie&gt; &amp;movies, vector&lt;movie&gt; &amp;selected, map&lt;int, int&gt; &amp;lim_cats, int n_cat) {\n1    int time_end = 0;\n1    int min_time = 100;\n1    bool has_selected = false;\n1    int times_filed = 0;\n1    movie last_selected = {0, 0, 0, 0};\n.    movie selected_movie;\n2,976    for(auto&amp; mov: movies) {\n.      3,000      if(n_cat &lt;= 0) return;\n2,000      if(times_filed &gt; 24) return;\n.  3,000      if(mov.end &gt; time_end) {\n.        time_end = mov.end;\n.  84        if (has_selected) {\n23          min_time = 100;\n96          include_movie(selected_movie, selected, times_filed);\n3,668  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:include_movie(movie&amp;, std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, int&amp;) (23x)\n92          set_cats_limit(lim_cats, selected_movie.cat, n_cat);\n1,691  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:set_cats_limit(std::map&lt;int, int, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;&amp;, int, int&amp;) (23x)\n46          last_selected = selected_movie;\n46          has_selected = false;\n.        };\n.      }\n7,034      if(mov.start &lt; min_time &amp;&amp; lim_cats[mov.cat] &gt; 0 &amp;&amp; hasSlot(mov, last_selected))  {\n78        selected_movie = mov;\n26        min_time = mov.start;\n26        has_selected = true;\n.      }\n.    }\n11  }\n.  12  int main(int argc, char *argv[]) {\n.    int n_mov, n_cat;\n.  .    map&lt;int, int&gt; lim_cats;\n.    vector&lt;movie&gt; movies, selected;\n.  7    cin &gt;&gt; n_mov &gt;&gt; n_cat;\n8,358  =&gt; ???:0x0000000000109200 (2x)\n.  1    movies.reserve(n_mov);\n.  4    set_cats_limit(lim_cats, n_cat);\n9,254  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:set_cats_limit(std::map&lt;int, int, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;&amp;, int) (1x)\n.  4    read_movies_data(movies, n_mov);\n3,294,712  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:read_movies_data(std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, int) (1x)\n.  .    sort(movies.begin(), movies.end(), [](auto&amp; i, auto&amp; j){return i.end &lt; j.end;});\n.  2    chrono::steady_clock::time_point begin = chrono::steady_clock::now();\n950  =&gt; ???:0x00000000001092d0 (1x)\n.  5    select_movies(movies, selected, lim_cats, n_cat);\n50,528  =&gt; guloso.cpp:select_movies(std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, std::map&lt;int, int, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;&amp;, int) (1x)\n.  1    chrono::steady_clock::time_point end = chrono::steady_clock::now();\n40  =&gt; ???:0x00000000001092d0 (1x)\n.  .    cout &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end - begin).count();\n.  2    if(argc &gt; 1) return 0;\n.  .    cout &lt;&lt; endl;\n    .  \n    2    print_agenda(selected);\n250,112  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:print_agenda(std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;) (1x)\n.  1    return 0;\n.  15  }\n</code></pre> <p>Como pode-se observar na an\u00e1lise do valgrind, as \u00fanicas func\u00f5es que tem pior desempenho s\u00e3o as de leitura dos inputs, e as de print da agenda - contudo as mesmas s\u00e3o chamadas apenas uma vez. As outras func\u00f5es s\u00e3o chamadas muitas vezes, mas n\u00e3o consomem tanto tempo, e a maior parte do tempo \u00e9 gasto em compara\u00e7\u00f5es e atribui\u00e7\u00f5es.</p>"},{"location":"#aleatorio","title":"Aleat\u00f3rio","text":""},{"location":"#funcao-de-selecao-de-filmes_1","title":"Funcao de selec\u00e3o de filmes","text":"<pre><code>int select_movies(vector&lt;movie&gt; &amp;movies, vector&lt;movie&gt; &amp;selected, map&lt;int, int&gt; &amp;lim_cats, map&lt;int, bool&gt; &amp;filled_slots, int n_cat, int n_mov);\n</code></pre> <p>argumentos:</p> <ul> <li><code>movies</code>: vetor de filmes a serem selecionados.</li> <li><code>selected</code>: vetor de filmes selecionados.</li> <li><code>lim_cats</code>: mapa de limites de filmes por categoria.</li> <li><code>filled_slots</code>: mapa de slots preenchidos - cada vez que um filme \u00e9 adicionado, ele preenche seus hor\u00e1rios no mapa.</li> <li><code>n_cat</code>: n\u00famero de categorias - utilizado para otimizac\u00e3o, cada vez que uma categoria \u00e9 preenchida (limite atingido), esse contador \u00e9 subtra\u00eddo, se o mesmo chega em zero (todas categorias atingiram o limite) o c\u00f3digo para.</li> <li><code>n_mov</code>: n\u00famero de filmes lido</li> <li><code>retorno</code>: tempo de tela total dos filmes selecionados.</li> </ul> <p>A l\u00f3gica da escolha \u00e9 feita da seguinte forma:</p> <ul> <li>Implementa a mesma l\u00f3gica descrita na gulosa</li> <li>Dentro do loop principal, checa se um filme aleat\u00f3rio pode ser adiconado - com 25% de chance</li> <li>Caso positivo:<ul> <li>Checa o limite de categorias e se o slot est\u00e1 dispon\u00edvel (cabe no hor\u00e1rio)</li> <li>Caso o filme seja adicionado, \u00e9 realizado um check para ver se o filme selecionado pela gulosa ainda cabe (categoria e slot)</li> </ul> </li> </ul>"},{"location":"#valgrind_1","title":"Valgrind","text":"<p><pre><code>-- line 3 ----------------------------------------\n    .  #include &lt;random&gt;\n.  #include &lt;chrono&gt;\n.  .  #define SEED 42\n.  #define PROB 0.75\n.  .  using namespace std;\n.  2,618  bool hasSlot(movie curr, map&lt;int, bool&gt; &amp;filled_slots) {\n724    if(curr.end == curr.start) return !filled_slots[curr.start];\n1,164    for(int i = curr.start; i &lt; curr.end; i++) {\n976      if(filled_slots[i]) return false;\n.    }\n14    return true;\n1,904  }\n.  121  void fill_slot(map&lt;int, bool&gt; &amp;filled_slots, movie curr) {\n33    if(curr.end == curr.start) {\n1      filled_slots[curr.start] = true;\n1      return;\n.    }\n136    for(int i = curr.start; i &lt; curr.end; i++) {\n24      filled_slots[i] = true;\n.    }\n88  }\n.  17  void select_movies(vector&lt;movie&gt; &amp;movies, vector&lt;movie&gt; &amp;selected, map&lt;int, int&gt; &amp;lim_cats, map&lt;int, bool&gt; &amp;filled_slots, int n_cat, int n_mov) {\n.    uniform_real_distribution&lt;double&gt; distribution(0.0, 1.0);\n.    default_random_engine generator;\n3    generator.seed(SEED + time(0));\n8  =&gt; ???:0x0000000000109260 (1x)\n.  2    int time_end = 0;\n1    int min_time = 100;\n1    int times_filed = 0;\n1    bool has_selected = false;\n.  .    //movie last_selected = {0, 0, 0, 0};\n.    movie selected_movie;\n844    for(int i = 0; i &lt; n_mov; i++) {\n848      if(n_cat &lt;= 0) return;\n424      if(times_filed &gt; 24) return;\n844      if(movies[i].end &gt; time_end) {\n.        time_end = movies[i].end;\n.  24        if (has_selected) {\n15          include_movie(selected_movie, selected, times_filed);\n344  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:include_movie(movie&amp;, std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, int&amp;) (3x)\n12          set_cats_limit(lim_cats, selected_movie.cat, n_cat);\n220  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:set_cats_limit(std::map&lt;int, int, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;&amp;, int, int&amp;) (3x)\n12          fill_slot(filled_slots, selected_movie);\n182  =&gt; aleatorio.cpp:fill_slot(std::map&lt;int, bool, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, bool&gt; &gt; &gt;&amp;, movie) (3x)\n.  9          min_time = 100;\n6          has_selected = false;\n.        };\n.      }\n422      if(distribution(generator) &gt; PROB) {\n48        uniform_int_distribution&lt;int&gt; distribution(i, movies.size()-1);\n.        int p = distribution(generator);\n561        if(hasSlot(movies[p], filled_slots) &amp;&amp; lim_cats[movies[p].cat] &gt; 0) {\n12,009  =&gt; aleatorio.cpp:hasSlot(movie, std::map&lt;int, bool, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, bool&gt; &gt; &gt;&amp;) (48x)\n24          include_movie(movies[p], selected, times_filed);\n2,601  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:include_movie(movie&amp;, std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, int&amp;) (8x)\n48          set_cats_limit(lim_cats, movies[p].cat, n_cat);\n549  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:set_cats_limit(std::map&lt;int, int, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;&amp;, int, int&amp;) (8x)\n48          fill_slot(filled_slots, movies[p]);\n1,064  =&gt; aleatorio.cpp:fill_slot(std::map&lt;int, bool, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, bool&gt; &gt; &gt;&amp;, movie) (8x)\n.          48          if(!(hasSlot(selected_movie, filled_slots) &amp;&amp; lim_cats[selected_movie.cat] &gt; 0)) {\n460  =&gt; aleatorio.cpp:hasSlot(movie, std::map&lt;int, bool, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, bool&gt; &gt; &gt;&amp;) (8x)\n16            min_time = 100;\n16            has_selected = false;\n.          }\n.        }\n.      }\n2,534      if(movies[i].start &lt; min_time &amp;&amp; lim_cats[movies[i].cat] &gt; 0 &amp;&amp; hasSlot(movies[i], filled_slots))  {\n11,881  =&gt; aleatorio.cpp:hasSlot(movie, std::map&lt;int, bool, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, bool&gt; &gt; &gt;&amp;) (182x)\n8        selected_movie = movies[i];\n8        min_time = movies[i].start;\n8        has_selected = true;\n.      }\n.    }\n11  }\n.  12  int main(int argc, char *argv[]) {\n.    int n_mov, n_cat;\n.    // int id, n, w, weigth, val;\n.  .    map&lt;int, bool&gt; filled_slots;\n.    map&lt;int, int&gt; lim_cats;\n.    vector&lt;movie&gt; movies, selected;\n.  8    cin &gt;&gt; n_mov &gt;&gt; n_cat;\n8,358  =&gt; ???:0x0000000000109210 (2x)\n.  1    movies.reserve(n_mov);\n.  5    set_cats_limit(lim_cats, n_cat);\n9,254  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:set_cats_limit(std::map&lt;int, int, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;&amp;, int) (1x)\n.  5    read_movies_data(movies, n_mov);\n3,294,712  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:read_movies_data(std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, int) (1x)\n.  .    sort(movies.begin(), movies.end(), [](auto&amp; i, auto&amp; j){return i.end &lt; j.end;});\n.  2    chrono::steady_clock::time_point begin = chrono::steady_clock::now();\n950  =&gt; ???:0x00000000001092f0 (1x)\n.  8    select_movies(movies, selected, lim_cats, filled_slots, n_cat, n_mov);\n55,592  =&gt; aleatorio.cpp:select_movies(std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;&amp;, std::map&lt;int, int, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;&amp;, std::map&lt;int, bool, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, bool&gt; &gt; &gt;&amp;, int, int) (1x)\n.  1    chrono::steady_clock::time_point end = chrono::steady_clock::now();\n40  =&gt; ???:0x00000000001092f0 (1x)\n.  .    cout &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end - begin).count();\n.  2    if(argc &gt; 1) return 0;\n.  .    cout &lt;&lt; endl;\n    .  \n    .    sort(selected.begin(), selected.end(), [](auto&amp; i, auto&amp; j){return i.start &lt; j.start;});\n.  2    print_agenda(selected);\n134,776  =&gt; /home/user/supercomp/project/helpers/helpers.cpp:print_agenda(std::vector&lt;movie, std::allocator&lt;movie&gt; &gt;) (1x)\n.  15  }\n--------------------------------------------------------------------------------\n</code></pre> Como pode-se observar na an\u00e1lise do valgrind, as \u00fanicas func\u00f5es que consomem mais tempo s\u00e3o as de leitura dos inputs, e as de print da agenda - contudo as mesmas s\u00e3o chamadas apenas uma vez. As outras func\u00f5es s\u00e3o chamadas muitas vezes, mas n\u00e3o consomem tanto tempo, e a maior parte do tempo \u00e9 gasto em compara\u00e7\u00f5es e atribui\u00e7\u00f5es. Se comparado ao guloso, a func\u00e3o <code>select_movies</code> do aleat\u00f3rio tem desempenho pior, pois a l\u00f3gica de validac\u00e3o para incluir um filme \u00e9 mais complexa - usa um dicion\u00e1rio, equanto na gulosa, como \u00e9 sequencial, apenas compara com o filme anterior.</p>"},{"location":"#resultados","title":"Resultados","text":""},{"location":"#overview-graficos-3d","title":"Overview (Gr\u00e1ficos 3D)","text":"<p>Tempo de execuc\u00e3o</p> Guloso Aleat\u00f3rio <p>Tempo de tela</p> Guloso Aleat\u00f3rio <p>Tempo de execuc\u00e3o</p> Guloso Aleat\u00f3rio"},{"location":"#aprofundando-graficos-2d","title":"Aprofundando (Gr\u00e1ficos 2D)","text":"<p>Tempo de execuc\u00e3o</p> 1 category 2 categories 3 categories 5 categories 10 categories 20 categories <p>Tempo de tela</p> 1 category 2 categories 3 categories 5 categories 10 categories 20 categories <p>Tempo de execuc\u00e3o</p> 1 category 2 categories 3 categories 5 categories 10 categories 20 categories"},{"location":"#conclusoes","title":"Conclus\u00f5es","text":""}]}